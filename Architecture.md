## Идея
Есть две нации - Россия и Германия. Первый игрок играет за Россию, 
второй - за Германию. Для каждой нации создается своя фабрика, 
которая может создавать ей воинов.

Солдаты обьединяются в армии (Army). У каждой армии есть экономическая (Economy) 
составляющая, отвечающая за финансы армии. Когда игрок хочет купить юнита, Economy 
проверяет, хватает ли ему на это денег. Армия получает новые деньги за 
уничтожение вражеских юнитов.

За ход игрок может либо создать нового война, либо отдать своей армии 
приказ на марш (влево или вправо) или на атаку.
Когда одна армия атакует, другая только защищается, не нападает в ответ.

## Архитектура
Каждая нация имеет два типа юнитов: Soldier и Sniper. Им соответствуют абстрактные 
классы с такими же названиями. Они наследуются от абстрактного класса Unit. 
Классы RussianSoldier, GermanSoldier наследуются от Soldier. Для Sniper - аналогично.

Для создания юнитов используется абстракная фабрика, потому что:
* Тут явно прослеживается двумерная структура. Есть разделение на две нации, а 
в каждой из наций - на типы воинов.
* Воины разных наций, но одного типа схожи между собой.
* Нужно создавать семейства обьектов, не привязываясь к конкретным 
классам создаваемых обьектов.

Для создания отрядов и армий используется паттерн Composite, потому что:
* Хочется работать с деревом юнитов как с одним обьектом
* Должна быть возможность легко добавлять новых юнитов
* Имеем дело с древовидной структурой

Unit - это компонента листа дерева, то есть одного юнита, а 
Army - армия, состоящая из Unit-ов.
Unit и Army наследуются от UnitsGroup, базовой компоненты.

Выдачу команд я реализовал с помочью паттерна Command, 
чтобы отделить игровую логику от интерфейса.
Таким образом, я создал классы CreateSniperCommand, CreateSoldierCommand, 
MoveLeftCommand, MoveRightCommand, AttackCommand, соответствующие командам к армии.

Класс Game отвечает за игру в целом. Он инициализирует армии и фабрики, а также -
получает сообщения от пользователей.

[Схема архитектуры](https://drive.google.com/file/d/1kgpVNMjmEqJVUYfuTLnlSw9DuL1Nl_OY/view?usp=sharing)

### Неиспользованные паттерны

**Observer**
Не использовал, потому что не нужна система подписок.
Она могла пригодиться в Field, который обновляет свои клетки 
на основе изменений в russianArmy и germanArmy.Однако я выбрал 
более простую реализацию: Field не хранит в себе состояния 
ячеек. Когда к нему приходит запрос, он узнает текущее состояние 
армий напрямую.

**Chain of Responsibility**
Обработка запросов сводится максимум к паре простых if-ов, 
поэтому реализовывать тут систему делегирования запросов 
нецелесообразно.

